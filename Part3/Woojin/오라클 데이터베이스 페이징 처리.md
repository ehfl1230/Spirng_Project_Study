# 오라클 데이터베이스 페이징 처리

페이징 처리는 시스템 부하나 처리 성능등의 이유로 한번에 일정 양만 가져와 처리하는 방식이다.
이는 요즘

1. 번호를 이용한 방법
2. '계속 보기'를 이용한 방법

등이 있다.

## **order by의 문제**

데이터베이스는 경우에 따라서 수백만 혹은 천 만개 이상의 데이터를 처리하기 때문에 이를 정렬하게 되면 많은 시간과 리소스를 소모하게 되어 1) 데이터가 적은 경우나 2) 정렬을 빠르게 할 수 있는 방법이 있지 않다면 사용에 주의해야 한다.

## **실행계획**

실행 계획은 말 그대로 SQL을 데이터베이스에서 어떻게 처리 할 것인가에 대한 것이다.
SQL이 데이터베이스에 전달되면 데이터베이스는 여러 단계를 거쳐 SQL을 어떤 순서와 방식으로 처리할 지 정한다.

1. SQL 파싱
2. SQL 최적화
3. SQL 실행

파싱 단계에서는 SQL 구문에 오류가 있는지 실행해야 하는 대상 객체가 존재하는 지를 검사하고,  
최적화 단계에는 SQL이 실행될 때 필요한 비용을 계산하고 이를 기초로 해서 어떤 방식으로 실행하는 것이 좋을지 '실행 계획'을 세우게 된다.
실행 단계에는 실행 계획을 통해서 메모리 상에서 데이터를 읽거나 물리적인 공간에서 데이터를 로딩하는 작업을 한다.

## **Order by 보다는 인덱스**

Order by는 테이블에 접근해 Sort를 처리하므로 연산 속도가 매우 느릴 수 있다.
따라서 Order by 보다는 PK 인덱스를 통한 where 조건으로 처리하면 Sort할 필요가 없고 이미 정렬된 PK를 통해 접근해 훨씬 빠른 연산처리를 할 수 있다.

## **인덱스와 오라클 힌트(HINT)**

힌트는 말 그대로 데이터베이스에 전달한 SQL문을 어떻게 실행할 지에 대한 힌트다. 힌트는 특이하게도 SQL문에 대한 이야기일 뿐이므로 구문에서 에러가 발생해도 SQL 실행에 지장을 주지 않는다.

힌트를 사용한 예시로는

게시물 목록이 반드시 시간의 역순으로 나와야 하는데 SQL에서는 주로 'order byu bno desc'와 같은 구문을 사용하지만, 상황에 따라서 이는 테이블의 모든 데이터를 정렬해야 하므로 시간이 오래 걸릴 수 있다. 따라서 아래와 같은 구문은 같은 동작을 하지만 2번째 SQL문이 시간이 적게 걸린다.

```
select * from tbl_board order by bno desc;

select /*+INDEX_DESC (tbl_board pk_board) */* from tbl_board;
```

### 힌트 사용 문법

힌트는 잘못 작성되어도 실행할 때는 무시 되지만 기본 문법은 다음과 같다.

1. '/*+'로 시작하고 '*/'로 마무리 된다.
2. SQL로 처리되지 않기 때문에 칼럼명이 나오더라도 별도의 ','를 쓰지 않는다.

### 자주 사용하는 힌트

1. FULL 힌트
   
FULL 힌트는 테이블의 모든 데이터를 스캔하도록 명시한다. 이는 데이터가 많을 경우 실행이 느리게 된다.

```
select /*+ FULL(tbl_board) */ * from tbl_board order by bno desc;
```

이러한 구문이 있으면 먼저 FULL로 인해 tbl_board의 전체 데이터를 스캔하고 그다음에 SORT를 하여 역순으로 정렬한다.

2. INDEX_ASC, INDEX_DESC 힌트

ASC/DESC에서 알 수 있듯 인덱스를 순서대로 이용하거나 역순으로 이용하거나 할 때 사용한다. 주로 Order by의 SORT 과정을 생략하기 위한 용도이다.

## **ROWNUM과 인라인뷰**

### Rownum

ROWNUM은 쉽게 생각해 SQL이 실행된 결과에 넘버링을 해준다고 생각하면 된다. 즉, SQL이 실행되어 나오는 결과값에 번호를 붙여주는 것이다.

이는 PK인 bno와는 다르게 데이터 인덱스와 같은 개념이 아닌 SQL 실행 결과의 인덱스 같은 개념으로 SQL 실행 결과에 따라 즉, 상황에 따라 값이 변할 수 있다.

이 ROWNUM을 페이징 처리하는 데 사용하면 아래와 같은 사항을 유의해야 한다.

한 페이지당 10개의 데이터를 출력한다고 가장하면 ROWNUM을 추가하여 다음과 같이 작성할 수 있다.

```
select /*+INDEX_DESC(tml_board pk_board) */
    rownum rn, bno, title, content
from
    tbl_board
where rownum <= 10;
```
이러면 가장 높은 번호의 게시물 10개가 출력된다.

이렇게 1페이지를 구했다면 흔히 동일한 방법으로 2페이지를 구할 것이라 생각하지만, 아쉽게도 

```
select /*+INDEX_DESC(tml_board pk_board) */
    rownum rn, bno, title, content
from
    tbl_board
where rownum > 10 and rownum <=20;
```
은 아무 결과가 나오지 않는다.

그 이유는 rownum은 위에서 말했듯이 SQL실행되어 나오는 결과값에 번호를 붙인것으로 처음 select문을 실행해서 TBL_BOARD에서 PK를 이용해 데이터를 찾은 것은 rownum값이 1이된다. 이는 조건에 맞지않고 무효화 된다. 그다음 찾은 데이터도 역시 rownum값이 1이되지만 조건에 맞지않아 무효화가 되어 아무 결과가 나오지 않는다.

따라서 SQL에 rownum을 넣는 경우 조건에는 항상 1이 포함되어야 한다.

```
select /*+INDEX_DESC(tml_board pk_board) */
    rownum rn, bno, title, content
from
    tbl_board
where rownum <= 20;
```

### 인라인뷰

위의 sql문은 2페이지의 데이터 20개를 가져오는 것이지 10~20개의 데이터를 가져오는 것은 아니다.
따라서 이 문제를 해결하기 위해 인라인 뷰를 사용해야 한다.

인라인 뷰는 쉽게 말해 SELECT문 안의 SELECT문이다. 즉, SELECT문을 실행한 결과로 다시 SELECT를 수행하는 것이다. 데이터베이스에는 테이블이나 인덱스와 같이 뷰(view)라는 개념이 존재한다. 뷰는 일종의 창문같은 개념으로 복잡한 SELECT 처리를 하나의 뷰로 생성하고 사용자들은 뷰를 통해서 복잡하게 만들어진 결과를 마치 하나의 테이블처럼 쉽게 조회한다는 개념이다. 인라인 뷰는 이러한 뷰의 작성을 별도로 하지 않고, FROM 구문 안에 바로 작성하는 형태이다.

```
SELECT ...
FROM(
    SELECT ...
    FROM ...
)
```

인라인 뷰를 적용한 2페이지 데이터의 처리는 아래와 같다.

```
select
    bno, title, content
from
    (
    select /*+INDEX_DESC(tbl_board pk_board) */
        rownum rn, bno, title, content
    from
        tbl_board
    where rownum <= 20
    )
where rn > 10;
```